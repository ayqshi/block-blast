function (require, module, exports) {
    "use strict";

    // Unregisters this module from the global Cocos Creator module registry.
    // The module ID "f00c3PmuJNFM5jdrDsLWYNy" and the name "blast" are used for internal tracking.
    cc._RF.push(module, "f00c3PmuJNFM5jdrDsLWYNy", "blast");

    // Helper function for JavaScript class inheritance, often generated by TypeScript.
    // 'childClass' extends 'parentClass'.
    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (child, parent) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(child, parent);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();

    // Helper function to apply decorators to classes and their members, common in TypeScript/Cocos Creator.
    // Used for @ccclass and @property.
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    // Mark this module as an ES module to enable 'import' functionality.
    Object.defineProperty(exports, "__esModule", { value: true });

    // Imports the API and control modules, which contain global game logic and settings.
    var apiModule = require("./api/api");
    var controlModule = require("./control");

    // Shorthand for Cocos Creator's decorator system.
    var ccDecorators = cc._decorator;
    var ccclass = ccDecorators.ccclass; // Decorator to register a class as a Cocos Creator component.
    var property = ccDecorators.property; // Decorator to expose properties in the editor.

    // This is the main game logic class, likely attached to the main scene's root node.
    var GameBlast = (function (_super) {
        // Constructor, initializes all properties.
        function GameBlast() {
            var _this = _super.apply(this, arguments) || this;
            _this.combo_node = null;
            _this.combo_track_ani = null;
            _this.destroy_layout_node = null;
            _this.destroy_pfb = null;
            _this.game_over_node = null;
            _this.guide_node = null;
            _this.no_space_left_node = null;
            _this.play_area = null;
            _this.tiles_node = null;
            _this.tile_pfb = null;
            _this.options_node = null;
            _this.opt_pfb = null;
            _this.d3rate = 1;
            _this.root = null;
            _this.score_lbl = null;
            _this.score_parent = null;
            _this.score_pfb = null;
            _this.audio_move = null;
            _this.audio_put = null;
            _this.audio_combo = [];
            _this.audio_grade = [];
            _this.audio_end = null;
            _this.audio_win = null;
            return _this;
        }

        // Apply inheritance: GameBlast extends cc.Component.
        __extends(GameBlast, _super);

        // Called when the component is first loaded. Sets up the initial game state.
        GameBlast.prototype.onLoad = function () {
            controlModule.control.view = this;
            controlModule.control.level = controlModule.control.settings.start_level;
            this.combo = 0;
            this.no_combo = 0;
            this.block_map = []; // A 2D array to represent the game board.
            this.toy_index = 0;
            this.initLevel();

            // Animate the grid at the start of the game.
            for (var i = 0; i < this.block_map.length; i++) {
                for (var j = 0; j < this.block_map[0].length; j++) {
                    var block = this.block_map[i][j];
                    if (block.getOpacity() < 255) {
                        block.setColor(Math.floor(7 * Math.random()));
                        block.setOpacityDelay(255, .1 * i + .5);
                    }
                    block.setOpacityDelay(0, .1 * (2 * this.block_map.length + 1 - i) + .5);
                }
            }
        };

        // Called when the game ends. Triggers the API's game_end function.
        GameBlast.prototype.onGameEnd = function () {
            cc.dLog("game_end");
            apiModule.API.game_end();
        };

        // Called when the Call-to-Action (CTA) button is clicked.
        GameBlast.prototype.onClickCTA = function () {
            apiModule.API.open();
        };

        // Tries to automatically click the CTA if the game settings allow it.
        GameBlast.prototype.autoClickCTA = function () {
            if (!this.auto_clicked_CTA && (this.auto_clicked_CTA = true, !apiModule.API.forbid_auto_CTA)) {
                try {
                    this.onClickCTA();
                } catch (error) {
                    cc.dLog(error);
                }
            }
        };

        // Gets the size of a single block tile based on the current level.
        GameBlast.prototype.getBlockSize = function () {
            return controlModule.control.settings.tile_size[controlModule.control.level - 1] || controlModule.control.settings.tile_size[0];
        };

        // A helper function to iterate through a 2D configuration array.
        GameBlast.prototype.checkConf = function (configArray, callback) {
            for (var i = 0; i < configArray.length; i++) {
                for (var j = 0; j < configArray.length; j++) {
                    var configItem = configArray[i][j] || {};
                    callback(configItem, i, j, configItem.q, configItem.a);
                }
            }
        };

        // Initializes a new game level.
        GameBlast.prototype.initLevel = function () {
            var currentLevel = controlModule.control.level;
            var levelConfig = controlModule.control.getLevelConf("level_" + currentLevel);
            this.initTiles(levelConfig);
            var guideConf = [];
            this.checkConf(levelConfig, function (configItem, i, j, q, a) {
                if (q > 0) {
                    guideConf[q - 1] = {
                        q: q,
                        a: a,
                        i: i,
                        j: j
                    };
                }
            });
            if (guideConf.length) {
                this.initGuide(guideConf);
            } else {
                this.initToys();
            }
        };

        // Advances to the next level after a delay.
        GameBlast.prototype.nextLevel = function () {
            var _this = this;
            this.scheduleOnce(function () {
                _this.initLevel();
            }, 2.5);
        };

        // Initializes the game board tiles based on the level configuration.
        GameBlast.prototype.initTiles = function (levelConfig) {
            var _this = this;
            this.tiles_node.removeAllChildren();
            var blockSize = this.getBlockSize();
            this.checkConf(levelConfig, function (configItem, row, col, q, a) {
                var newTile = cc.instantiate(_this.tile_pfb);
                newTile.parent = _this.tiles_node;
                var blockComponent = newTile.getComponent("block");
                if (blockComponent) {
                    blockComponent.setSize(blockSize);
                    blockComponent.i = row;
                    blockComponent.j = col;
                    newTile.x = (col - levelConfig[0].length / 2) * blockSize;
                    newTile.y = (row - levelConfig.length / 2) * blockSize;
                    _this.block_map[row] = _this.block_map[row] || [];
                    _this.block_map[row][col] = blockComponent;
                    if (q === 0 && a > 0) {
                        // This seems to be a pre-filled block
                        blockComponent.setColor(a);
                        blockComponent.ori_color_num = a;
                    } else if (a !== 0) {
                        // This seems to be a transparent guide block
                        blockComponent.setOpacity(50);
                        var guideColor = controlModule.control.settings.guide_conf[controlModule.control.level - 1].color;
                        blockComponent.setColor(guideColor);
                        blockComponent.ori_color_num = guideColor;
                    } else {
                        // An empty, invisible block
                        blockComponent.setOpacity(0);
                    }
                }
            });
        };

        // Initializes the guide for a guided level.
        GameBlast.prototype.initGuide = function (guideConfig) {
            var guideItem = guideConfig.pop();
            if (guideItem) {
                guideItem.toy_color = controlModule.control.settings.guide_conf[controlModule.control.level - 1].color;
                this.guide_node.active = true;
                var newOption = cc.instantiate(this.opt_pfb);
                newOption.getComponent("opt").init(this.tile_pfb, guideItem, 1);
                newOption.parent = this.options_node;
            }
        };

        // Checks if the game is in portrait mode.
        GameBlast.prototype.isPortrait = function () {
            return true;
        };

        // Gets the autoplay configuration from the model settings.
        GameBlast.prototype.getAutoPlayConf = function () {
            return controlModule.control.model.config.auto_play || [];
        };

        // Initializes the three toy options for the player.
        GameBlast.prototype.initToys = function () {
            var _this = this;
            var toyColors = controlModule.control.getShuffleArr(7, 1).splice(0, 3);
            if (this.getAutoPlayConf().length) {
                this.opt_comps = [];
                for (var i = 0; i < 3; i++) {
                    var newOption = cc.instantiate(this.opt_pfb);
                    var autoPlayData = this.getAutoPlayConf()[this.toy_index];
                    var toyAnswer = autoPlayData[0];
                    var toyColor = autoPlayData[1];
                    var toyOrder = autoPlayData[2];
                    var toyTargetX = autoPlayData[3];
                    var toyTargetY = autoPlayData[4];
                    this.toy_index++;
                    var optComponent = newOption.getComponent("opt");
                    newOption.parent = this.options_node;
                    optComponent.init(this.tile_pfb, {
                        a: toyAnswer,
                        toy_color: toyColor || toyColors[i],
                        toy_order: toyOrder,
                        toy_target_x: toyTargetX,
                        toy_target_y: toyTargetY
                    }, i);
                    this.opt_comps.push(optComponent);
                }
                this.scheduleOnce(function () {
                    _this.autoPut(0);
                }, .5);
            } else {
                var hasValidSpot = false;
                var toyList = [];
                for (var i = 0; i < 3; i++) {
                    this.toy_index++;
                    var newToy = controlModule.control.getRandomToy();
                    if (this.hasSeat(controlModule.control.getToyConf(newToy).shape)) {
                        hasValidSpot = true;
                    }
                    toyList.push(newToy);
                }
                if (!hasValidSpot) {
                    var randomIndex = Math.floor(Math.random() * toyList.length);
                    for (; ;) {
                        var newToy = controlModule.control.getRandomToy();
                        if (this.hasSeat(controlModule.control.getToyConf(newToy).shape)) {
                            toyList[randomIndex] = newToy;
                            break;
                        }
                    }
                }
                for (var i = 0; i < toyList.length; i++) {
                    var newOption = cc.instantiate(this.opt_pfb);
                    var toyId = toyList[i];
                    newOption.getComponent("opt").init(this.tile_pfb, {
                        a: toyId,
                        toy_color: toyColors[i]
                    }, i);
                    newOption.parent = this.options_node;
                }
            }
        };

        // Automates placing a toy if an autoplay configuration is provided.
        GameBlast.prototype.autoPut = function (currentOrder, hasDelay) {
            var nextToyComponent;
            for (var i = 0; i < this.opt_comps.length; i++) {
                var toyComponent = this.opt_comps[i];
                if (toyComponent.auto_order > currentOrder && (!cc.isValid(nextToyComponent) || nextToyComponent.auto_order > toyComponent.auto_order)) {
                    nextToyComponent = toyComponent;
                }
            }
            if (cc.isValid(nextToyComponent)) {
                this.scheduleOnce(function () {
                    nextToyComponent.autoPut();
                }, hasDelay ? 1.1 : .3);
            }
        };

        // Handles logic after a toy has been successfully placed.
        GameBlast.prototype.onPutToy = function () {
            var _this = this;
            this.scheduleOnce(function () {
                if (_this.checkGameOver()) {
                    _this.gameOver();
                }
                if (_this.options_node.children.length === 0) {
                    _this.initToys();
                }
            });
        };

        // Checks if there are any valid moves left on the board.
        GameBlast.prototype.checkGameOver = function () {
            if (this.options_node.children.length === 0) {
                return false;
            }
            for (var i = 0; i < this.options_node.children.length; i++) {
                if (this.hasSeat(this.options_node.children[i].getComponent("opt").shape)) {
                    return false;
                }
            }
            return true;
        };

        // Manages the game over state, including animations and audio.
        GameBlast.prototype.gameOver = function () {
            var _this = this;
            cc.dLog("game_over");
            this.is_game_over = true;
            this.no_space_left_node.active = true;
            controlModule.control.playAudio(this.audio_end);

            for (var i = 0; i < this.block_map.length; i++) {
                for (var j = 0; j < this.block_map[0].length; j++) {
                    var block = this.block_map[i][j];
                    if (block.getOpacity() < 255) {
                        block.setColor(Math.floor(7 * Math.random()));
                        block.setOpacityDelay(255, .1 * i + .5);
                    }
                    block.setOpacityDelay(0, .1 * (2 * this.block_map.length + 1 - i) + .5);
                }
            }
            this.scheduleOnce(function () {
                controlModule.control.playAudio(_this.audio_win);
                location.reload();
            }, 2.5);
        };

        // Configures a particle effect node for a destroyed tile.
        GameBlast.prototype.configDestroyNode = function (nodeToDestroy, yPosition, color) {
            nodeToDestroy.parent = controlModule.control.view.destroy_layout_node;
            var destroyChild = nodeToDestroy.getChildByName("destroy");
            controlModule.control.setHSL(destroyChild, controlModule.control.getHSL(color, 1));
            destroyChild.y = yPosition;
            destroyChild.x = controlModule.control.settings.destroy_pos[0];
            var animationDuration = (destroyChild.getComponent(cc.Animation).defaultClip.duration || 50) + 1 / 30;
            this.scheduleOnce(function () {
                nodeToDestroy.destroy();
            }, animationDuration);
        };

        // Checks if there is a valid empty space on the board for a given toy shape.
        GameBlast.prototype.hasSeat = function (toyShape) {
            var blockMap = this.block_map;
            var toyPoints = [];
            for (var i = 0; i < toyShape.length; i++) {
                for (var j = 0; j < toyShape[0].length; j++) {
                    if (toyShape[i][j]) {
                        toyPoints.push([toyShape.length - 1 - i, j]);
                    }
                }
            }
            for (var i = 1 - toyShape.length; i < blockMap.length + 2 * toyShape.length - 1; i++) {
                for (var j = 1 - toyShape[0].length; j < blockMap[0].length + 2 * toyShape[0].length - 1; j++) {
                    var hasValidSpot = true;
                    for (var k = 0; k < toyPoints.length; k++) {
                        var targetI = i + toyPoints[k][0];
                        var targetJ = j + toyPoints[k][1];
                        if (!blockMap[targetI] || !blockMap[targetI][targetJ] || blockMap[targetI][targetJ].getOpacity() !== 0) {
                            hasValidSpot = false;
                            break;
                        }
                    }
                    if (hasValidSpot) {
                        return true;
                    }
                }
            }
            return false;
        };

        // Adds score and updates the score label.
        GameBlast.prototype.addScore = function (scoreToAdd) {
            var currentScore = Number(this.score_lbl.string);
            this.total_score = this.total_score || 0;
            this.total_score += scoreToAdd;
            controlModule.control.scrolNum(this.score_lbl, currentScore, this.total_score, .2);
        };

        // Handles the logic after a toy is placed, including score, combo, and audio.
        GameBlast.prototype.handlePut = function (linesCleared, score, position) {
            var _this = this;
            if (linesCleared) {
                this.combo++;
                this.no_combo = 0;
                controlModule.control.playAudio(this.audio_combo[Math.min(this.combo - 1, this.audio_combo.length - 1)]);
                this.autoClickCTA();
            } else {
                this.no_combo++;
                if (this.no_combo === 3) {
                    this.no_combo = 0;
                    this.combo = 0;
                    cc.tween(this.combo_node).to(.3, { opacity: 0 }).start();
                }
                controlModule.control.playAudio(this.audio_put);
            }
            this.addScore(score);
            if (this.combo > 2 && linesCleared > 0) {
                controlModule.control.shakeNode(this.root, 30, 10 / 30, 5);
                this.combo_node.active = true;
                this.combo_node.opacity = 255;
                this.combo_track_ani.play();
            }
            if (position) {
                var scoreNode = cc.instantiate(this.score_pfb);
                scoreNode.parent = this.score_parent;
                var adjustedPosition = position.add(cc.v3(this.getBlockSize() / 2, this.getBlockSize() / 2, 0));
                if (adjustedPosition.x < -120) {
                    adjustedPosition.x = -120;
                } else if (adjustedPosition.x > 120) {
                    adjustedPosition.x = 120;
                }
                scoreNode.position = adjustedPosition;
                scoreNode.getComponent("score").showScore({
                    combo: Math.max(this.combo - 1, 0),
                    bingo_lines: linesCleared
                });
                if (linesCleared >= 2) {
                    this.scheduleOnce(function () {
                        controlModule.control.playAudio(_this.audio_grade[Math.min(linesCleared - 2, _this.audio_grade.length - 1)]);
                    }, .7);
                }
            }
        };

        // Apply @property decorators to expose properties to the Cocos Creator editor.
        __decorate([property(cc.Node)], GameBlast.prototype, "combo_node", void 0);
        __decorate([property(cc.Animation)], GameBlast.prototype, "combo_track_ani", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "destroy_layout_node", void 0);
        __decorate([property(cc.Prefab)], GameBlast.prototype, "destroy_pfb", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "game_over_node", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "guide_node", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "no_space_left_node", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "play_area", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "tiles_node", void 0);
        __decorate([property(cc.Prefab)], GameBlast.prototype, "tile_pfb", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "options_node", void 0);
        __decorate([property(cc.Prefab)], GameBlast.prototype, "opt_pfb", void 0);
        __decorate([property(cc.Float)], GameBlast.prototype, "d3rate", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "root", void 0);
        __decorate([property(cc.Label)], GameBlast.prototype, "score_lbl", void 0);
        __decorate([property(cc.Node)], GameBlast.prototype, "score_parent", void 0);
        __decorate([property(cc.Prefab)], GameBlast.prototype, "score_pfb", void 0);
        __decorate([property(cc.AudioClip)], GameBlast.prototype, "audio_move", void 0);
        __decorate([property(cc.AudioClip)], GameBlast.prototype, "audio_put", void 0);
        __decorate([property([cc.AudioClip])], GameBlast.prototype, "audio_combo", void 0);
        __decorate([property([cc.AudioClip])], GameBlast.prototype, "audio_grade", void 0);
        __decorate([property(cc.AudioClip)], GameBlast.prototype, "audio_end", void 0);
        __decorate([property(cc.AudioClip)], GameBlast.prototype, "audio_win", void 0);
        __decorate([ccclass], GameBlast);

        return GameBlast;
    })(cc.Component);

    // Set the default export of this module to the GameBlast class.
    exports.default = GameBlast;

    // Pops the module off the internal Cocos Creator module stack, indicating it's done loading.
    cc._RF.pop();
}