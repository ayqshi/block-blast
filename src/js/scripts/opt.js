function (require, module, exports) {
    "use strict";

    // Unregisters this module from the global Cocos Creator module registry.
    // The module ID "3f42esDz0pNFYybnD0voKt+" and the name "opt" are for internal tracking.
    cc._RF.push(o, "3f42esDz0pNFYybnD0voKt+", "opt");

    // Helper function for class inheritance, typically generated by TypeScript.
    var __extends = (this && this.__extends) || (function () {
        // ... (standard inheritance boilerplate)
    })();

    // Helper function to apply decorators to classes and their members.
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        // ... (standard decorator boilerplate)
    };

    // Mark this module as an ES module.
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    // Imports the control and model singletons.
    var controlModule = require("../control");
    var modelModule = require("../model");

    // Shorthand for Cocos Creator's decorator system.
    var ccDecorators = cc._decorator;
    var ccclass = ccDecorators.ccclass; // Decorator to register a class as a Cocos Creator component.
    var property = ccDecorators.property; // Decorator to expose properties in the editor.

    /**
     * Cocos Creator component for a "toy" piece. This component manages the visual representation,
     * user interaction (dragging), and placement logic for a single toy piece. The name "opt"
     * likely stands for "option," as it represents one of the available toy pieces.
     */
    var OptComponent = (function (_super) {
        __extends(OptComponent, _super);

        function OptComponent() {
            var _this = _super.apply(this, arguments) || this;
            _this.birth_node = null; // Node where the toy is spawned.
            _this.toy_node = null; // The main node containing all the blocks of the toy.
            _this.btn = null; // The node that listens for touch/click events (likely a button).
            _this.block_sd_pfb = null; // Prefab for a block's shadow/depth effect.
            return _this;
        }

        /**
         * Cocos Creator lifecycle method called when the component is loaded.
         * It initializes arrays for tracking game state and sets up touch event listeners.
         */
        OptComponent.prototype.onLoad = function () {
            this.fs_list = []; // List of blocks on the grid that are filled by this toy.
            this.bingo_i = []; // List of row indices that will be cleared.
            this.bingo_j = []; // List of column indices that will be cleared.
            this.btn.on(cc.Node.EventType.TOUCH_START, this.touchStart, this);
            this.btn.on(cc.Node.EventType.TOUCH_MOVE, this.touchMove, this);
            this.btn.on(cc.Node.EventType.TOUCH_END, this.touchEnd, this);
            this.btn.on(cc.Node.EventType.TOUCH_CANCEL, this.touchEnd, this);
        };

        /**
         * Initializes the toy piece with its specific configuration.
         * @param {cc.Prefab} blockPrefab The prefab for a single block.
         * @param {Object} toyData Configuration data for the toy piece, including shape, color, etc.
         * @param {number} positionIndex The index of this option (e.g., 1st, 2nd, or 3rd option).
         */
        OptComponent.prototype.init = function (blockPrefab, toyData, positionIndex) {
            this.view = controlModule.control.view;
            this.toy_index = toyData.a;
            var toyConf = controlModule.control.getToyConf(this.toy_index);
            this.guide_q = toyData.q;
            this.guide_i = toyData.i;
            this.guide_j = toyData.j;
            this.shape = toyConf.shape;
            this.auto_order = toyData.toy_order;
            var block_size = controlModule.control.block_size;
            var toyTargetX = toyData.toy_target_x;
            var toyTargetY = toyData.toy_target_y;
            var toy_size = modelModule.model.TOY_SIZE;

            // Calculate the toy's bounding box to center it visually.
            var minX = toy_size, maxX = 0, minY = toy_size, maxY = 0;
            for (var y = 0; y < toy_size; y++) {
                for (var x = 0; x < toy_size; x++) {
                    if (this.shape[y][x]) {
                        minX = Math.min(x, minX);
                        maxX = Math.max(x, maxX);
                        minY = Math.min(y, minY);
                        maxY = Math.max(y, maxY);
                    }
                }
            }
            var centerOffset = [
                -(minX + maxX + 1) / 2 * block_size * controlModule.control.d3rate,
                (maxY + minY - 9) / 2 * block_size * controlModule.control.d3rate
            ];

            // If in auto-play mode, calculate the target position.
            if (this.auto_order) {
                var targetBlock = this.view.block_map[toyTargetY][toyTargetX].node;
                this.toy_target_pos = targetBlock.position.subtract(this.node.parent.position).add(cc.v3(40 * (Math.random() - 0.5), 40 * (Math.random() - 0.5), 0));
                this.toy_target_pos.addSelf(cc.v3(((maxX - minX + 1) % 2) / 2 * block_size, ((maxY - minY + 1) % 2) / 2 * block_size, 0));
            }

            // Set the color for the toy. Override if it's a guided game.
            this.color_idx = toyData.toy_color;
            if (this.guide_q) {
                this.color_idx = controlModule.control.settings.guide_conf[controlModule.control.level - 1].color;
            }

            // Instantiate the individual blocks of the toy.
            for (var y = 0; y < toy_size; y++) {
                for (var x = 0; x < toy_size; x++) {
                    if (this.shape[y][x]) {
                        var newBlockNode = cc.instantiate(blockPrefab);
                        var blockX = x * block_size + centerOffset[0];
                        var blockY = (toy_size - y - 1) * block_size + centerOffset[1];
                        newBlockNode.x = blockX;
                        newBlockNode.y = blockY;
                        var blockComponent = newBlockNode.getComponent("block");
                        blockComponent.setSize(block_size, null);
                        blockComponent.setColor(this.color_idx, false, 1, function () {}, false);
                        blockComponent.ori_color_num = this.color_idx;

                        // Instantiate and position the shadow block if available.
                        if (cc.isValid(this.block_sd_pfb)) {
                            var shadowBlock = cc.instantiate(this.block_sd_pfb);
                            shadowBlock.x = blockX;
                            shadowBlock.y = blockY;
                            var shadowSprite = shadowBlock.getChildByName("spr");
                            if (cc.isValid(shadowSprite)) {
                                var shadowSize = 1.8 * block_size;
                                shadowSprite.anchorY = 1 - 1 / 1.8;
                                shadowSprite.y = 0;
                                shadowSprite.width = shadowSize;
                                shadowSprite.height = shadowSize;
                            }
                            shadowBlock.parent = this.toy_node;
                            shadowBlock.zIndex = 0;
                        }

                        newBlockNode.parent = this.toy_node;
                        newBlockNode.zIndex = 1;
                    }
                }
            }

            // Animate the toy's appearance with a slight bounce.
            this.toy_node.scale = this.getScale();
            this.node.x = 200 * (positionIndex - 1);
            this.node.scale = 0;
            cc.tween(this.node).to(0.2, {
                scale: 1.08
            }).to(0.05, {
                scale: 1
            }).start();
        };

        /**
         * Handles the automatic placement of the toy piece.
         */
        OptComponent.prototype.autoPut = function () {
            var _this = this;
            this.auto_moving = true;
            this.node.zIndex = 1;
            cc.tween(this.toy_node).to(0.2, {
                scale: 1
            }).start();
            cc.tween(this.node).delay(0.35).to(0.4, {
                position: this.toy_target_pos
            }, {
                easing: controlModule.control.ease("easeOutCubic")
            }).delay(0.07).call(function () {
                _this.putOn();
                _this.node.destroy();
            }).start();
        };

        /**
         * Cocos Creator lifecycle method that runs every frame.
         * It calls `onCheckBlocks` when the toy is in an automatic movement state.
         */
        OptComponent.prototype.update = function () {
            if (this.auto_moving) {
                this.onCheckBlocks();
            }
        };

        /**
         * Handles the start of a touch/drag interaction.
         */
        OptComponent.prototype.touchStart = function (event) {
            if (!this.clicking && !this.view.is_game_over) {
                this.view.guide_node.active = false;
                controlModule.control.play_started = true;
                controlModule.control.playAudio(this.view.audio_move, false);
                this.birth_node.active = false;
                this.node.zIndex = 1;
                this.clicking = true;
                this.ori_pos = this.node.position;
                this.toy_node.stopAllActions();
                var touchLocation = event.getLocation();
                this.node.position = this.getOptionTouchPos(touchLocation);
                this.toy_node.scale = 1;
            }
        };

        /**
         * Handles the movement of a touch/drag.
         */
        OptComponent.prototype.touchMove = function (event) {
            if (this.clicking && !this.view.is_game_over) {
                var touchLocation = event.getLocation();
                this.node.position = this.getOptionTouchPos(touchLocation);
                this.onCheckBlocks();
            }
        };

        /**
         * Converts touch coordinates to a position relative to the options node.
         * @param {cc.Vec2} touchLocation The touch position in screen space.
         * @returns {cc.Vec3} The converted position.
         */
        OptComponent.prototype.getOptionTouchPos = function (touchLocation) {
            var resolution = controlModule.control.getResolution();
            var screenWidth = resolution.width;
            var screenHeight = resolution.height;
            var view = this.view;
            var optionsScale = view.options_node.scale;
            var offsetX = view.isPortrait() ? 0 : -100;
            var offsetY = view.isPortrait() ? 200 : 40;
            var newX = (touchLocation.x - screenWidth / 2) / optionsScale - view.options_node.x / optionsScale + offsetX;
            var newY = (touchLocation.y - screenHeight / 2) / optionsScale - view.options_node.y / optionsScale + offsetY;
            return cc.v3(newX, newY, 0);
        };

        /**
         * Handles the end of a touch/drag interaction.
         */
        OptComponent.prototype.touchEnd = function () {
            if (this.clicking && !this.view.is_game_over) {
                this.node.zIndex = 0;
                this.clicking = false;
                if (this.checkAllow()) {
                    this.putOn();
                    this.node.destroy();
                } else {
                    // Snap back to the original position if placement is not allowed.
                    cc.tween(this.node).to(0.05, {
                        position: this.ori_pos
                    }).start();
                    cc.tween(this.toy_node).to(0.05, {
                        scale: this.getScale()
                    }).start();
                    this.cancle();
                }
            }
        };

        /**
         * Checks if the current placement position is valid.
         * It also verifies if the placement matches a guided tutorial if one is active.
         * @returns {boolean} True if the placement is valid, otherwise false.
         */
        OptComponent.prototype.checkAllow = function () {
            if (this.fs_list.length) {
                if (!this.guide_q) {
                    return true;
                }
                // Check if the placement matches the guided position.
                var guideShape = [];
                var shapeHeight = this.shape.length;
                var shapeWidth = this.shape[0].length;
                for (var y = 0; y < shapeHeight; y++) {
                    for (var x = 0; x < shapeWidth; x++) {
                        if (this.shape[y][x]) {
                            guideShape.push([this.guide_i + y - (shapeHeight - 1), this.guide_j + x - (shapeWidth >> 1)]);
                        }
                    }
                }
                for (var i = 0; i < this.fs_list.length; i++) {
                    var placedBlock = this.fs_list[i];
                    var isGuidedPosition = false;
                    for (var j = 0; j < guideShape.length; j++) {
                        if (placedBlock.i === guideShape[j][0] && placedBlock.j === guideShape[j][1]) {
                            isGuidedPosition = true;
                            break;
                        }
                    }
                    if (!isGuidedPosition) {
                        return false;
                    }
                }
                controlModule.control.nextLevel();
                return true;
            }
            return false;
        };

        /**
         * Cocos Creator lifecycle method called when the component is destroyed.
         * It triggers the `onPutToy` event on the main game view.
         */
        OptComponent.prototype.onDestroy = function () {
            if (!this.guide_q) {
                this.view.onPutToy();
            }
        };

        /**
         * Executes the placement of the toy on the game board and handles line/column clearing.
         */
        OptComponent.prototype.putOn = function () {
            var _this = this;
            var toySpawnPosition = null;
            var blockMap = this.view.block_map;
            var linesClearedCount = 0;

            // Handle row clearing (bingo_i).
            for (var i = 0; i < this.bingo_i.length; i++) {
                var rowIndex = this.bingo_i[i];
                for (var j = 0; j < blockMap[rowIndex].length; j++) {
                    blockMap[rowIndex][j].setOpacity(0);
                }
                linesClearedCount++;
                var destroyEffect = cc.instantiate(controlModule.control.view.destroy_pfb);
                this.view.configDestroyNode(destroyEffect, (rowIndex - blockMap[rowIndex].length / 2) * controlModule.control.block_size + controlModule.control.settings.destroy_pos[1], this.color_idx);
            }

            // Handle column clearing (bingo_j).
            for (var i = 0; i < this.bingo_j.length; i++) {
                var colIndex = this.bingo_j[i];
                for (var j = 0; j < blockMap.length; j++) {
                    blockMap[j][colIndex].setOpacity(0);
                }
                linesClearedCount++;
                var destroyEffect = cc.instantiate(controlModule.control.view.destroy_pfb);
                destroyEffect.angle = -90;
                this.view.configDestroyNode(destroyEffect, (colIndex - blockMap[colIndex].length / 2) * controlModule.control.block_size + controlModule.control.settings.destroy_pos[1], this.color_idx);
            }

            // Update the blocks with the new toy.
            this.fs_list.map(function (block) {
                if (block.getOpacity() === 0) {
                    // This block was already part of a line cleared by this placement.
                    if (!toySpawnPosition) {
                        toySpawnPosition = block.node.position;
                    }
                } else {
                    block.setOpacity(255);
                    block.ori_color_num = _this.color_idx;
                }
            });

            // Notify the main game view of the changes.
            var blockCount = this.shape.reduce(function (total, row) {
                return total + row.reduce(function (subtotal, value) {
                    return subtotal + value;
                }, 0);
            }, 0);
            this.view.handlePut(linesClearedCount, blockCount, toySpawnPosition);

            if (this.auto_moving) {
                this.auto_moving = false;
                this.view.autoPut(this.auto_order, linesClearedCount);
            }
        };

        /**
         * Cancels a placement and resets the board's visual state.
         */
        OptComponent.prototype.cancle = function () {
            var blockMap = this.view.block_map;
            for (var i = 0; i < blockMap.length; i++) {
                for (var j = 0; j < blockMap[0].length; j++) {
                    var block = blockMap[i][j];
                    if (block.getOpacity() < 255) {
                        block.setOpacity(0);
                    }
                    block.setColor(block.ori_color_num);
                }
            }
        };

        /**
         * Calculates the scale for the toy based on game settings.
         * @returns {number} The scale value.
         */
        OptComponent.prototype.getScale = function () {
            return controlModule.control.settings.opt_tile_size / controlModule.control.block_size;
        };

        /**
         * Checks the current position of the toy and updates the visual feedback on the game board.
         * This is the core logic for highlighting valid placement spots and potential line/column clears.
         */
        OptComponent.prototype.onCheckBlocks = function () {
            var blockMap = this.view.block_map;
            var blockSize = controlModule.control.block_size;
            var canPlace = true;
            var blocksUnderToy = [];

            // Reset highlight state and arrays.
            this.fs_list = [];
            this.bingo_i = [];
            this.bingo_j = [];

            // Find blocks on the board that are under the toy piece.
            for (var i = 0; i < this.toy_node.children.length; i++) {
                var blockPlaced = false;
                for (var y = 0; y < blockMap.length; y++) {
                    for (var x = 0; x < blockMap[0].length; x++) {
                        var boardBlock = blockMap[y][x];

                        // Reset visual state of all board blocks.
                        if (boardBlock.getOpacity() < 255) {
                            boardBlock.setOpacity(0);
                        }
                        boardBlock.setColor(boardBlock.ori_color_num);

                        // Check for overlap.
                        if (canPlace) {
                            var toyBlockPosition = this.toy_node.children[i].convertToWorldSpaceAR(cc.v2(0, 0));
                            var localPos = boardBlock.node.convertToNodeSpaceAR(toyBlockPosition);
                            if (localPos.x >= -blockSize / 2 && localPos.x < blockSize / 2 && localPos.y >= -blockSize / 2 && localPos.y < blockSize / 2) {
                                if (boardBlock.getOpacity() === 0) {
                                    blockPlaced = true;
                                }
                                blocksUnderToy.push(boardBlock);
                            }
                        }
                    }
                }
                if (!blockPlaced) {
                    canPlace = false;
                }
            }

            // If a valid placement is possible, highlight the blocks and check for "bingos".
            if (canPlace) {
                var checkedRows = [];
                var checkedCols = [];

                for (var i = 0; i < blocksUnderToy.length; i++) {
                    var boardBlock = blocksUnderToy[i];
                    if (boardBlock.getOpacity() === 0) {
                        boardBlock.setColor(this.color_idx);
                        boardBlock.setOpacity(127);
                        this.fs_list.push(boardBlock);
                    }
                }
                
                for (var i = 0; i < blocksUnderToy.length; i++) {
                    var boardBlock = blocksUnderToy[i];
                    var row = boardBlock.i;
                    var col = boardBlock.j;

                    // Check for a complete row.
                    if (checkedRows.indexOf(row) === -1) {
                        checkedRows.push(row);
                        var isFullRow = true;
                        for (var j = 0; j < blockMap[row].length; j++) {
                            if (blockMap[row][j].getOpacity() <= 0) {
                                isFullRow = false;
                                break;
                            }
                        }
                        if (isFullRow) {
                            this.bingo_i.push(row);
                            for (var j = 0; j < blockMap[row].length; j++) {
                                blockMap[row][j].setColor(this.color_idx);
                                // The original code has a call to addGlow here.
                            }
                        }
                    }

                    // Check for a complete column.
                    if (checkedCols.indexOf(col) === -1) {
                        checkedCols.push(col);
                        var isFullCol = true;
                        for (var j = 0; j < blockMap.length; j++) {
                            if (blockMap[j][col].getOpacity() <= 0) {
                                isFullCol = false;
                                break;
                            }
                        }
                        if (isFullCol) {
                            this.bingo_j.push(col);
                            for (var j = 0; j < blockMap.length; j++) {
                                blockMap[j][col].setColor(this.color_idx);
                                blockMap[j][col].setOpacity(150);
                            }
                        }
                    }
                }
            }
        };

        // Apply @property decorators to expose properties in the editor.
        __decorate([property(cc.Node)], OptComponent.prototype, "birth_node", void 0);
        __decorate([property(cc.Node)], OptComponent.prototype, "toy_node", void 0);
        __decorate([property(cc.Node)], OptComponent.prototype, "btn", void 0);
        __decorate([property(cc.Prefab)], OptComponent.prototype, "block_sd_pfb", void 0);
        // Apply @ccclass decorator to register this class as a Cocos Creator component.
        __decorate([ccclass], OptComponent);

        return OptComponent;
    })(cc.Component);

    // Set the default export of this module to the OptComponent class.
    exports.default = OptComponent;

    // Pops the module off the internal Cocos Creator module stack.
    cc._RF.pop();
}