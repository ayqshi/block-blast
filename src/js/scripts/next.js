function (require, module, exports) {
    "use strict";

    // Unregisters this module from the global Cocos Creator module registry.
    // The module ID "f2473nZfEJLo5zJoiLrIO48" and the name "next" are for internal tracking.
    cc._RF.push(module, "f2473nZfEJLo5zJoiLrIO48", "next");

    // Helper function for JavaScript class inheritance, often generated by TypeScript.
    // 'childClass' extends 'parentClass'.
    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (child, parent) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(child, parent);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();

    // Helper function to apply decorators to classes and their members, common in TypeScript/Cocos Creator.
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    // Mark this module as an ES module.
    Object.defineProperty(exports, "__esModule", { value: true });

    // Imports the control module, which is a singleton with global game logic.
    var controlModule = require("./control");
    // Imports the model module, which contains game data and configurations.
    var modelModule = require("./model");

    // Shorthand for Cocos Creator's decorator system.
    var ccDecorators = cc._decorator;
    var ccclass = ccDecorators.ccclass; // Decorator to register a class as a Cocos Creator component.
    var property = ccDecorators.property; // Decorator to expose properties in the editor.

    /**
     * Cocos Creator component for the "Next Toy" display, which shows the upcoming game piece.
     * It handles the visual representation and the selection logic for the next toy.
     */
    var NextToyComponent = (function (_super) {
        // Constructor initializes component properties.
        function NextToyComponent() {
            var _this = _super.apply(this, arguments) || this;
            _this.changeAudio = null; // Audio clip for when the toy is changed.
            _this.changeIcon = null; // Node for the change icon.
            _this.selectionActiveNode = null; // Node indicating that a selection is active.
            _this.mainAnimation = null; // Main animation component for the next toy display.
            _this.currentToyNode = null; // The current toy node that is being played.
            _this.nextToyNode = null; // The node representing the next upcoming toy.
            _this.nextToyShadowNode = null; // The shadow node for the next toy.
            _this.nextSelectionAnimation = null; // Animation for the next toy's selection state.
            _this.guideAnimation = null; // Animation for the guide (tutorial) element.
            _this.guideNode = null; // Node for the guide (tutorial) element.
            return _this;
        }

        // Apply inheritance: NextToyComponent extends cc.Component.
        __extends(NextToyComponent, _super);

        /**
         * Cocos Creator lifecycle method: Called when the component is first loaded.
         */
        NextToyComponent.prototype.onLoad = function () {
            this.poped = true; // A flag to track if the next toy has "popped" into place.
        };

        /**
         * Initializes the component with a specific index and a reference to its parent component.
         * @param {object} params An object containing the index and parent component reference.
         * @param {number} params.idx The index of this next toy slot.
         * @param {object} params.parent_comp A reference to the parent component.
         */
        NextToyComponent.prototype.init = function (params) {
            this.index = params.idx;
            this.parentComponent = params.parent_comp;
        };

        /**
         * Automatically triggers the selection action for this next toy, typically for a guided tutorial.
         */
        NextToyComponent.prototype.autoTouchSel = function () {
            this.guideNode.active = true;
            this.playGuide();
        };

        /**
         * Plays the guide animation.
         */
        NextToyComponent.prototype.playGuide = function () {
            this.parentComponent.playGuide(this.index);
        };

        /**
         * Handles the auto-touch selection logic. If the guide animation is not set to loop, it proceeds with the normal touch selection.
         */
        NextToyComponent.prototype.onAutoTouchSel = function () {
            if (this.guideAnimation.defaultClip.wrapMode !== cc.WrapMode.Loop) {
                this.onTouchSel();
            }
        };

        /**
         * Handles the user's touch/click event on the next toy.
         * This function manages the logic for swapping the current toy with the next one.
         */
        NextToyComponent.prototype.onTouchSel = function () {
            var _this = this;
            if (controlModule.control.view.touchListening) {
                // If in a guided tutorial and the user touches the wrong toy, do nothing.
                if (this.parentComponent.in_guide) {
                    if (this.parentComponent.guide_idx !== this.index) {
                        return;
                    }
                    this.parentComponent.in_guide = false;
                    this.guideAnimation.setCurrentTime(0);
                    this.guideAnimation.stop();
                    controlModule.control.view.configGuideNode();
                } else if (controlModule.control.view.timer === -1) {
                    // If the game is paused, do nothing.
                    return;
                }

                // Mark the game as started and play the change audio.
                controlModule.control.play_started = true;
                controlModule.control.playAudio(this.changeAudio, false);

                var view = controlModule.control.view;

                // Perform the toy swap if all necessary nodes and configurations exist.
                if (!this.poped && this.nextToyNode && this.toyConfig && view.cur_toy_conf && view.toy_node) {
                    this.nextSelectionAnimation.play();
                    // Generate new nodes for the current and next toy.
                    view.genToyNode(view.toy_index, this.toyConfig, view.toy_node, view.toy_shadow_node, view.toy_fs_node);
                    view.genToyNode(null, view.cur_toy_conf, this.nextToyNode, this.nextToyShadowNode);

                    // Swap the toy configurations.
                    var tempToyConfig = {
                        shape: {},
                        color: null
                    };
                    tempToyConfig.shape = view.cur_toy_conf.shape;
                    tempToyConfig.color = view.cur_toy_conf.color;
                    view.cur_toy_conf.shape = this.toyConfig.shape;
                    view.cur_toy_conf.color = this.toyConfig.color;
                    this.toyConfig.shape = tempToyConfig.shape;
                    this.toyConfig.color = tempToyConfig.color;

                    // Recalculate game limits and positions.
                    view.calcLRLimit();
                    view.calcLRLimit2(view.toy_node.y);
                    view.toy_fs_node.position = view.getTargetPos(view.toy_node.x + view.play_area.x / 2 + view.block_size);
                    this.adjustPosCenter();
                }
            }
        };

        /**
         * Adjusts the position of the next toy node to be centered based on its shape.
         */
        NextToyComponent.prototype.adjustPosCenter = function () {
            var shape = this.toyConfig.shape;
            var toySize = modelModule.model.TOY_SIZE;
            var minCol = toySize;
            var maxCol = 0;
            var minRow = toySize;
            var maxRow = 0;

            // Find the bounding box of the toy shape.
            for (var row = 0; row < toySize; row++) {
                for (var col = 0; col < toySize; col++) {
                    if (shape[row][col]) {
                        minCol = col < minCol ? col : minCol;
                        maxCol = col > maxCol ? col : maxCol;
                        minRow = row < minRow ? row : minRow;
                        maxRow = row > maxRow ? row : maxRow;
                    }
                }
            }
            // Calculate the new centered position.
            var centeredPosition = [
                -(minCol + maxCol - 2) / 2 * controlModule.control.block_size * controlModule.control.d3rate,
                (maxRow + minRow - 9) / 2 * controlModule.control.block_size * controlModule.control.d3rate
            ];

            // Apply the new position to the next toy and its shadow.
            controlModule.control.view.setPos(this.nextToyNode, centeredPosition);
            controlModule.control.view.setPos(this.nextToyShadowNode, centeredPosition);
        };

        /**
         * Updates the next toy's visual representation and state.
         * @param {number} birthIndex The index related to the birth of the toy.
         * @param {number} toyIndex The index of the next toy in the configuration.
         * @param {boolean} isInitial A flag indicating if this is the initial update.
         */
        NextToyComponent.prototype.updateNext = function (birthIndex, toyIndex, isInitial) {
            var _this = this;
            var totalIndex = birthIndex + toyIndex;
            var nextToyConfig = controlModule.control.getToyConf(totalIndex);
            var nextToyNode = this.nextToyNode;
            var nextToyShadowNode = this.nextToyShadowNode;
            var mainAnimationNode = this.mainAnimation.node;

            // Clear any old child nodes.
            nextToyNode.removeAllChildren();
            nextToyShadowNode.removeAllChildren();

            // Set shadow visibility based on game settings.
            nextToyShadowNode.active = controlModule.control.settings.next_show_sd === 1;

            this.toyConfig = nextToyConfig;
            this.adjustPosCenter();
            controlModule.control.view.genToyNode(null, nextToyConfig, nextToyNode, nextToyShadowNode);

            // Scale the toy node.
            this.currentToyNode.scale = controlModule.control.settings.next_toy_scale[0];

            if (isInitial) {
                mainAnimationNode.scale = 0;
                // Use a scheduled function to delay the animation.
                this.scheduleOnce(function () {
                    _this.poped = false;
                    cc.tween(_this.changeIcon).to(0.2, { scale: 1.08 }).to(0.1, { scale: 1 }).start();
                    if (cc.isValid(mainAnimationNode) && mainAnimationNode.getComponent(cc.Animation)) {
                        mainAnimationNode.getComponent(cc.Animation).play();
                    }
                }, birthIndex * controlModule.control.settings.next_toy_birth_gap + controlModule.control.settings.next_update_gap);
            } else {
                this.poped = false;
                this.changeIcon.scale = 1;
                mainAnimationNode.scale = 1;
            }
        };

        /**
         * Animates the "popping" or removal of the next toy, typically when it becomes the current toy.
         * @param {function} callback A function to call after the pop animation finishes.
         */
        NextToyComponent.prototype.popNext = function (callback) {
            this.poped = true;
            this.changeIcon.stopAllActions();
            cc.tween(this.changeIcon).to(0.3, { scale: 0 }).start();
            this.mainAnimation.play("next_pop");
            this.mainAnimation.once("finished", function () {
                if (callback) {
                    callback();
                }
            }, this);
        };

        /**
         * Applies a color change function to all child nodes of the next toy.
         * @param {function} colorFunction A function that takes a node and applies a color change to it.
         */
        NextToyComponent.prototype.changeToyColor = function (colorFunction) {
            this.nextToyNode.children.map(function (childNode) {
                colorFunction(childNode);
            });
        };

        /**
         * Configures and starts the guide animation for this component.
         * This sets the animation to loop and plays it.
         */
        NextToyComponent.prototype.showGuide = function () {
            this.guideAnimation.defaultClip.wrapMode = cc.WrapMode.Loop;
            this.guideAnimation.defaultClip.speed = 0.5;
            this.playGuide();
        };

        // Apply @property decorators to expose properties in the editor.
        __decorate([property(cc.AudioClip)], NextToyComponent.prototype, "changeAudio", void 0);
        __decorate([property(cc.Node)], NextToyComponent.prototype, "changeIcon", void 0);
        __decorate([property(cc.Node)], NextToyComponent.prototype, "selectionActiveNode", void 0);
        __decorate([property(cc.Animation)], NextToyComponent.prototype, "mainAnimation", void 0);
        __decorate([property(cc.Node)], NextToyComponent.prototype, "currentToyNode", void 0);
        __decorate([property(cc.Node)], NextToyComponent.prototype, "nextToyNode", void 0);
        __decorate([property(cc.Node)], NextToyComponent.prototype, "nextToyShadowNode", void 0);
        __decorate([property(cc.Animation)], NextToyComponent.prototype, "nextSelectionAnimation", void 0);
        __decorate([property(cc.Animation)], NextToyComponent.prototype, "guideAnimation", void 0);
        __decorate([property(cc.Node)], NextToyComponent.prototype, "guideNode", void 0);
        // Apply @ccclass decorator to register this class as a Cocos Creator component.
        __decorate([ccclass], NextToyComponent);

        return NextToyComponent;
    })(cc.Component);

    // Set the default export of this module to the NextToyComponent class.
    exports.default = NextToyComponent;

    // Pops the module off the internal Cocos Creator module stack, indicating it's done loading.
    cc._RF.pop();
}
    //i miss my ex gf. lol