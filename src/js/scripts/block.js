function (require, module, exports) {
    "use strict";

    // Unregisters this module from the global Cocos Creator module registry.
    // The module ID "0982eQ7W+ZNPKeS1fuQ7WiV" and the name "block" are for internal tracking.
    cc._RF.push(module, "0982eQ7W+ZNPKeS1fuQ7WiV", "block");

    // Helper function for JavaScript class inheritance, often generated by TypeScript.
    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (child, parent) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(child, parent);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();

    // Helper function to apply decorators to classes and their members, common in TypeScript/Cocos Creator.
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    // Mark this module as an ES module.
    Object.defineProperty(exports, "__esModule", { value: true });

    // Imports the control module.
    var controlModule = require("./control");
    var ccDecorators = cc._decorator;
    var ccclass = ccDecorators.ccclass; // Decorator to register a class as a Cocos Creator component.
    var property = ccDecorators.property; // Decorator to expose properties in the editor.

    /**
     * Represents a single block in the game, handling its appearance and animations.
     */
    var BlockComponent = (function (_super) {
        // Constructor, initializes the properties.
        function BlockComponent() {
            var _this = _super.apply(this, arguments) || this;
            _this.animationComponent = null;
            _this.meshRenderer = null;
            _this.spriteAnimations = null;
            _this.sprite2Animations = null;
            _this.dropColorAnimation = null;
            _this.dropAnimation = null;
            _this.destroyAnimation = null;
            return _this;
        }

        // Apply inheritance: BlockComponent extends cc.Component.
        __extends(BlockComponent, _super);

        /**
         * The start method is a standard Cocos Creator lifecycle function.
         */
        BlockComponent.prototype.start = function () { };

        Object.defineProperty(BlockComponent.prototype, "settings", {
            /**
             * Getter for game settings from the global control module.
             * @returns {object} The game settings object.
             */
            get: function () {
                return controlModule.control.settings;
            },
            enumerable: false,
            configurable: true
        });

        /**
         * Sets the color of the 3D mesh renderer.
         * @param {cc.Node} node The node containing the mesh renderer.
         * @param {number} colorIndex The index of the color to use.
         */
        BlockComponent.prototype.set3dColor = function (node, colorIndex) {
            if (cc.isValid(node)) {
                var material = this.meshRenderer.getMaterial(0);
                var hslColor = controlModule.control.getHSL(colorIndex, 0, true);
                var rgbaColor = new Float32Array([hslColor[0] / 255, hslColor[1] / 255, hslColor[2] / 255, 1]);
                material.setProperty("diffuseColor", rgbaColor, 0);
            }
        };

        /**
         * Sets the color of the block's sprite or 3D mesh.
         * @param {number} colorIndex The index of the color.
         * @param {boolean} is3d A flag to check if the block is a 3D object.
         * @param {number} spriteSet A value indicating which sprite set to use (1 or 2).
         * @param {function} callback A function to call after setting the color.
         * @param {boolean} isSpriteSet2 A flag to specifically use the second sprite set.
         */
        BlockComponent.prototype.setColor = function (colorIndex, is3d, spriteSet, callback, isSpriteSet2) {
            spriteSet = spriteSet || 1;
            var targetSpriteAnimations = this.sprite2Animations;

            if (!isSpriteSet2) {
                targetSpriteAnimations = this.spriteAnimations;
                this.color_num = colorIndex;
            }

            if (is3d) {
                // Set color for the 3D block
                this.set3dColor(this.node.getChildByName("block3d"), colorIndex);
                // Handle another 3D object if settings allow
                if (!this.settings.d3_texture_div || this.settings.d3_texture_div === 1) {
                    this.set3dColor(this.node.getChildByName("box"), colorIndex);
                }
                callback && callback();
            } else {
                switch (spriteSet) {
                    case 1:
                        if (cc.isValid(targetSpriteAnimations)) {
                            this.setNodeColor(targetSpriteAnimations, colorIndex);
                        }
                        callback && callback();
                        break;
                    case 2:
                        controlModule.control.setHSL(targetSpriteAnimations.node, controlModule.control.getHSL(colorIndex, 0));
                        callback && callback();
                        break;
                }
            }
        };

        /**
         * Sets the sprite frame of a node based on a color index.
         * @param {cc.Animation} animationComponent The animation component to target.
         * @param {number} colorIndex The index of the color.
         */
        BlockComponent.prototype.setNodeColor = function (animationComponent, colorIndex) {
            colorIndex = colorIndex || this.color_num;
            var spriteFrames = animationComponent.defaultClip.curveData.comps["cc.Sprite"].spriteFrame;
            var spriteFrame = spriteFrames[colorIndex - 1] || spriteFrames[0];
            animationComponent.node.getComponent(cc.Sprite).spriteFrame = spriteFrame.value;
        };

        /**
         * Sets the size of the block and its child nodes.
         * @param {number} gridSize The size of the grid cell.
         * @param {number} scaleFactor The scaling factor to apply.
         */
        BlockComponent.prototype.setSize = function (gridSize, scaleFactor) {
            scaleFactor = scaleFactor || 1;
            var blockWidth = gridSize - this.settings.block_space;
            var blockNode = this.node;
            var spriteNode = this.spriteAnimations.node;
            var sprite2Node = this.sprite2Animations.node;
            var block3dNode = this.node.getChildByName("block3d");
            var boxNode = this.node.getChildByName("box");
            var destroyAniNode = this.node.getChildByName("destroy_ani");

            if (cc.isValid(spriteNode)) {
                spriteNode.width = blockWidth;
                spriteNode.height = blockWidth;
                spriteNode.position = cc.v2(blockWidth / 2, blockWidth / 2);
                if (cc.isValid(sprite2Node)) {
                    sprite2Node.width = blockWidth;
                    sprite2Node.height = blockWidth;
                    spriteNode.position = cc.v2(blockWidth / 2, blockWidth / 2);
                }
                if (cc.isValid(destroyAniNode)) {
                    destroyAniNode.width = blockWidth;
                    destroyAniNode.height = blockWidth;
                    destroyAniNode.position = cc.v2(blockWidth / 2, blockWidth / 2);
                }
            } else {
                if (cc.isValid(block3dNode)) {
                    blockNode.scale = scaleFactor * blockWidth / gridSize;
                }
                if (cc.isValid(boxNode)) {
                    blockNode.box = boxNode;
                    blockNode.scale = scaleFactor * blockWidth / gridSize;
                }
            }
        };

        /**
         * Plays the drop animation.
         */
        BlockComponent.prototype.playDropAni = function () {
            this.dropAnimation.play();
        };

        /**
         * Plays the destruction animation with a delay.
         * @param {number} totalCount The total number of blocks in the destruction chain.
         * @param {number} index The index of this block in the destruction chain.
         */
        BlockComponent.prototype.playDestroyAni = function (totalCount, index) {
            var _this = this;
            var delay = 0.02 * Math.abs(index - totalCount / 2);
            this.destroyAnimation.node.active = true;
            this.destroyAnimation.play();
            this.scheduleOnce(function () {
                _this.animationComponent.play("block_destroy");
            }, delay);
        };

        /**
         * A callback function that deactivates the node when the destroy animation finishes.
         */
        BlockComponent.prototype.onBlockDestroy = function () {
            this.node.active = false;
        };

        /**
         * Sets the opacity of the main sprite node.
         * @param {number} opacity The new opacity value (0-255).
         */
        BlockComponent.prototype.setOpacity = function (opacity) {
            this.spriteAnimations.node.opacity = opacity;
        };

        /**
         * Sets the opacity of the main sprite node after a delay.
         * @param {number} opacity The new opacity value (0-255).
         * @param {number} delay The delay in seconds.
         */
        BlockComponent.prototype.setOpacityDelay = function (opacity, delay) {
            var _this = this;
            this.scheduleOnce(function () {
                _this.spriteAnimations.node.opacity = opacity;
            }, delay);
        };

        /**
         * Gets the current opacity of the main sprite node.
         * @returns {number} The current opacity value.
         */
        BlockComponent.prototype.getOpacity = function () {
            return this.spriteAnimations.node.opacity;
        };

        // Apply @property decorators to expose properties in the editor.
        __decorate([property(cc.Animation)], BlockComponent.prototype, "animationComponent", void 0);
        __decorate([property(cc.MeshRenderer)], BlockComponent.prototype, "meshRenderer", void 0);
        __decorate([property(cc.Animation)], BlockComponent.prototype, "spriteAnimations", void 0);
        __decorate([property(cc.Animation)], BlockComponent.prototype, "sprite2Animations", void 0);
        __decorate([property(cc.Animation)], BlockComponent.prototype, "dropColorAnimation", void 0);
        __decorate([property(cc.Animation)], BlockComponent.prototype, "dropAnimation", void 0);
        __decorate([property(cc.Animation)], BlockComponent.prototype, "destroyAnimation", void 0);
        __decorate([ccclass], BlockComponent);

        return BlockComponent;
    })(cc.Component);

    // Set the default export of this module to the BlockComponent class.
    exports.default = BlockComponent;

    // Pops the module off the internal Cocos Creator module stack.
    cc._RF.pop();
}