function (require, module, exports) {
    "use strict";

    // Unregisters this module from the global Cocos Creator module registry.
    // The module ID "38a37PduI5MS7mPwrExGLXj" and the name "star" are for internal tracking.
    cc._RF.push(module, "38a37PduI5MS7mPwrExGLXj", "star");

    // Helper function for JavaScript class inheritance, often generated by TypeScript.
    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (child, parent) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(child, parent);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();

    // Helper function to apply decorators to classes and their members, common in TypeScript/Cocos Creator.
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    // Mark this module as an ES module.
    Object.defineProperty(exports, "__esModule", { value: true });

    // Imports the control module. This is likely a global game controller or manager.
    var controlModule = require("./control");

    // Shorthand for Cocos Creator's decorator system.
    var ccDecorators = cc._decorator;
    var ccclass = ccDecorators.ccclass; // Decorator to register a class as a Cocos Creator component.
    var property = ccDecorators.property; // Decorator to expose properties in the editor.

    /**
     * Cocos Creator component for managing star-based objectives in a game.
     * It handles the collection of stars, progress bar updates, and game-over conditions.
     */
    var StarComponent = (function (_super) {
        // Constructor initializes component properties.
        function StarComponent() {
            var _this = _super.apply(this, arguments) || this;
            _this.starSpriteFrames = []; // Array of SpriteFrames for different star types.
            _this.showProgress = false; // A boolean to enable/disable the progress bar animation.
            _this.particlePrefab = null; // A prefab for a particle effect.
            _this.flyAudio = null; // AudioClip to play when a star flies to its target.
            _this.genAudio = null; // AudioClip to play when a star is generated.
            _this.starStatList = []; // An array to store the state of each star objective.
            return _this;
        }

        // Apply inheritance: StarComponent extends cc.Component.
        __extends(StarComponent, _super);

        /**
         * Cocos Creator lifecycle method: Called when the component is first loaded.
         * It initializes a reference to the global game controller and sets up the star targets.
         */
        StarComponent.prototype.onLoad = function () {
            this.ctrl = controlModule.control;
            this.initTargetList();
        };

        /**
         * Initializes the `starStatList` by finding all star nodes in the scene.
         * It populates the list with each star's ID, current progress, target count, and progress bar component.
         */
        StarComponent.prototype.initTargetList = function () {
            this.stars = this.node.children; // Get all child nodes of this component.
            for (var i in this.stars) {
                var starNode = this.stars[i];
                var starSubNode = starNode.getChildByName("star_node");
                var targetCount = 1;
                var countLabelNode = starNode.getChildByName("lbl");

                // Get the target count from the label's string if it's active.
                if (countLabelNode.active) {
                    targetCount = Number(countLabelNode.getComponent(cc.Label).string);
                }

                // Iterate through the children of the star node to find the active star type.
                for (var j in starSubNode.children) {
                    var starTypeNode = starSubNode.children[j];
                    if (starTypeNode.active) {
                        var progressBar = starTypeNode.getChildByName("prgs").getComponent(cc.ProgressBar);
                        progressBar.progress = 0;
                        // Push a new entry to the stat list: [star ID, current count, target count, progress bar].
                        this.starStatList.push([Number(starTypeNode.name.split("_")[1]), 0, targetCount, progressBar]);
                        break;
                    }
                }
            }
        };

        /**
         * A helper function to parse an entry from `starStatList` into a more readable object.
         */
        StarComponent.prototype.parseStatData = function (statArray) {
            return {
                id: statArray[0],
                current: statArray[1],
                target: statArray[2],
                progressBar: statArray[3]
            };
        };

        /**
         * Adds progress to a star objective and triggers its animation.
         * @param {number} starId The ID of the star type (e.g., 11 for the first star).
         * @param {cc.Vec2} startPosition The starting position of the flying star effect.
         */
        StarComponent.prototype.addStar = function (starId, startPosition) {
            var _this = this;
            // Iterate through the star objectives to find the matching one.
            for (var i = 0; i < this.starStatList.length; i++) {
                var starStat = this.starStatList[i];
                // Check if the star ID matches and the target hasn't been reached yet.
                if (starStat[0] === starId && starStat[1] < starStat[2]) {
                    starStat[1]++; // Increment the current count.
                    this.checkGameOver();

                    // Create and configure a temporary node for the flying star effect.
                    var flyingStarNode = new cc.Node();
                    var particleEffectNode = cc.instantiate(this.particlePrefab);
                    var starSpriteNode = new cc.Node();

                    starSpriteNode.parent = flyingStarNode;
                    starSpriteNode.zIndex = 10;
                    starSpriteNode.addComponent(cc.Sprite).spriteFrame = this.starSpriteFrames[starId - 11];

                    flyingStarNode.parent = this.node;
                    flyingStarNode.position = startPosition.subtract(this.node.position);
                    flyingStarNode.scale = 0.2;

                    // Play the 'generate' audio if not already playing.
                    var audioPlayed = this.played_audio;
                    this.played_audio = true;
                    if (!audioPlayed) {
                        this.ctrl.playAudio(this.genAudio, false);
                    }

                    // Define a complex tween sequence for the flying star animation.
                    var tweenSequence = cc.tween(flyingStarNode)
                        .to(0.4, { scale: 1.1 })
                        .call(function () {
                            _this.played_audio = false;
                            particleEffectNode.parent = flyingStarNode;
                            particleEffectNode.zIndex = 1;
                        })
                        .to(0.1, { scale: 1 })
                        .delay(0.3)
                        .call(function () {
                            if (!audioPlayed) {
                                _this.ctrl.playAudio(_this.flyAudio, false);
                            }
                            // Spin the star sprite node during the flight.
                            cc.tween(starSpriteNode).by(1, { angle: 1080 }).start();
                        })
                        // Use a parallel tween for the bezier path and scale change.
                        .parallel(
                            cc.tween().bezierTo(1, cc.v2(0, -640), cc.v2(200, -640), starStat[3].node.parent.parent.parent.position),
                            cc.tween().to(1, { scale: starStat[3].node.parent.parent.scale })
                        );

                    // If `showProgress` is enabled, shrink the flying star as it reaches the destination.
                    if (this.showProgress) {
                        tweenSequence = tweenSequence.to(0.3, { scale: 0 });
                    }

                    // After the tween finishes, update the progress bar and remove the temporary node.
                    tweenSequence.call(function () {
                        _this.ctrl.prgsTo(starStat[3], 1, 0.5);
                        _this.removeStar(flyingStarNode);
                    }).start();

                    // Exit the loop after finding and processing the correct star.
                    return "break";
                }
            }
        };

        /**
         * Checks if the game's objective is complete by verifying if all stars have been collected.
         */
        StarComponent.prototype.checkGameOver = function () {
            var allStarsCollected = true;
            for (var i = 0; i < this.starStatList.length; i++) {
                var stat = this.starStatList[i];
                // Check if the current count is less than the target count.
                if (stat[1] < stat[2]) {
                    allStarsCollected = false;
                }
            }
            // If all stars are collected, trigger the game over event.
            if (allStarsCollected) {
                this.gameOver("star", true, 3);
            }
        };

        /**
         * Schedules the removal of a temporary node after a short delay.
         * @param {cc.Node} nodeToRemove The node to be removed.
         */
        StarComponent.prototype.removeStar = function (nodeToRemove) {
            this.scheduleOnce(function () {
                if (cc.isValid(nodeToRemove)) {
                    nodeToRemove.removeFromParent();
                }
            }, 0.5);
        };

        // Apply @property decorators to expose properties in the editor.
        __decorate([property([cc.SpriteFrame])], StarComponent.prototype, "starSpriteFrames", void 0);
        __decorate([property(cc.Boolean)], StarComponent.prototype, "showProgress", void 0);
        __decorate([property(cc.Prefab)], StarComponent.prototype, "particlePrefab", void 0);
        __decorate([property(cc.AudioClip)], StarComponent.prototype, "flyAudio", void 0);
        __decorate([property(cc.AudioClip)], StarComponent.prototype, "genAudio", void 0);
        // Apply @ccclass decorator to register this class as a Cocos Creator component.
        __decorate([ccclass], StarComponent);

        return StarComponent;
    })(cc.Component); // The StarComponent class extends cc.Component.

    // Set the default export of this module to the StarComponent class.
    exports.default = StarComponent;

    // Pops the module off the internal Cocos Creator module stack, indicating it's done loading.
    cc._RF.pop();
}